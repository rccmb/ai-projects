;;;; program.lisp
;;;; Related to user interaction and interface.
;;;; Author: Rodrigo Baptista 202200217

(defparameter *generated-nodes* 0 "Total number of generated nodes.")
(defparameter *expanded-nodes* 0 "Total number of expanded nodes.")
(defparameter *total-pieces* 0 "Total number of pieces in puzzle.")

(defparameter *output-file*
  (merge-pathnames "log.dat" (make-pathname :directory (pathname-directory *load-pathname*)))
)

(defparameter *input-file*
  (merge-pathnames "problems.dat" (make-pathname :directory (pathname-directory *load-pathname*)))
)

(load (merge-pathnames "game.lisp" (make-pathname :directory (pathname-directory *load-pathname*))))
(load (merge-pathnames "search.lisp" (make-pathname :directory (pathname-directory *load-pathname*))))

(defun initialize () ; TODO CHECK THIS AGAIN.
  (progn 
    (setq *generated-nodes* 0)
    (setq *expanded-nodes* 0)
    (setq *total-pieces* 0)
    (let 
      ((initial-node (create-node (read-initial-state) 0 0 nil)))
      (progn
        (setq *total-pieces* (board-piece-count (node-state initial-node)))
        (let* 
          (
            (algorithm (read-algorithm))
            (depth 
              (cond
                ((eq algorithm 'dfs) (read-depth))
              ))
            (heuristic
              (cond
                ((eq algorithm 'a-star) (read-heuristic))
              ))
            (start-time (get-internal-real-time)))
          (cond 
            ((node-solutionp initial-node) (format t "Error, the initial node can't be a solution node.~%")) ; Edge-case, the initial node is a solution node, end execution.
            ((eq algorithm 'bfs) (show-result (funcall algorithm 'node-solutionp 'generate-children 'game-operator (list initial-node)) 'bfs start-time))
            ((eq algorithm 'dfs) (show-result (funcall algorithm 'node-solutionp 'generate-children 'game-operator depth (list initial-node)) 'dfs start-time))
            ((eq algorithm 'a-star) (show-result (funcall algorithm 'node-solutionp 'generate-children 'game-operator heuristic (list initial-node)) 'a-star start-time))
          )
        )
      )
    )
  )
)

(defun read-initial-state ()
  (with-open-file (stream *input-file*)
    (let ((state (read stream)))
      state)
  )
)

(defun read-depth ()
  (progn 
    (format t "What's the max depth of the search tree generated by the DFS algorithm? ~%")
    (let 
      ((depth (read)))
      (if (and (numberp depth) (> depth 0))
        depth
        (read-depth)) 
    )
  )
)

(defun read-heuristic ()
  (progn 
    (format t "What's the heuristic function to be used? ~%")
    (let 
      ((heuristic (read)))
      (if (fboundp heuristic)
        heuristic
        (read-heuristic))
    )
  )
)

(defun read-algorithm ()
  (progn
    (format t "What algorithm to use? ~%")
    (format t "1 - BFS ~%")
    (format t "2 - DFS ~%")
    (format t "3 - A* ~%")
    (let 
      ((algorithm (read)))
      (cond 
        ((= algorithm 1) 'bfs)
        ((= algorithm 2) 'dfs)
        ((= algorithm 3) 'a-star)
        (t (read-algorithm))
      )
    )
  )
)

(defun show-node (node &optional algorithm)
  (progn 
    (format t "NODE: ~%")
    (format t "- State: ~A~%" (node-state node))
    (format t "- Depth: ~D~%" (node-depth node))
    (if (eq algorithm 'a-star)
      (progn
        (format t "- Heuristic: ~A~%" (node-heuristic node))
        (format t "- Cost: ~A~%" (node-cost node))
      ) 
      nil
    )
  )
)

; (defun calculate-branching-factor (depth total-generated)
;   "Estimate the branching factor B based on the DEPTH and TOTAL-GENERATED nodes. Slide 39 - 3."
;   (let ((b 1.1)
;         (delta 0.01)) 
;     (loop
;       (let ((estimated-t (+ (* b (expt b depth)) (/ b (- b 1)))))
;         (if (< (abs (- estimated-t total-generated)) delta)
;             b
;             (setf b (+ b delta)))))
;   )
; )

(defun show-result (solution algorithm start-time)
  (let* 
    (
      (end-time (get-internal-real-time))
      (time-taken (/ (- end-time start-time) (/ internal-time-units-per-second 1000)))
      (penetrance (/ (node-depth solution) *generated-nodes*))
      ; (branching-factor (calculate-branching-factor (node-depth solution) *generated-nodes*))
    )
    (with-open-file (stream *output-file* :direction :output :if-exists :append :if-does-not-exist :create)
      (cond 
        ((eq algorithm 'bfs) (format stream "Results from BFS (Breadth-First-Search): ~%"))
        ((eq algorithm 'dfs) (format stream "Results from DFS (Depth-First-Search): ~%"))
        ((eq algorithm 'a-star) (format stream "Results from A*: ~%"))
      )
      (format t "Time taken: ~Dms~%" time-taken)
      (format stream "Time taken: ~Dms~%" time-taken)
      (format t "The number of total generated nodes is: ~D~%" *generated-nodes*)
      (format t "The number of total expanded nodes is: ~D~%" *expanded-nodes*)
      (format stream "The number of total generated nodes is: ~D~%" *generated-nodes*)
      (format stream "The number of total expanded nodes is: ~D~%" *expanded-nodes*)
      (format t "The penetrance is: ~D~%" penetrance)
      (format stream "The penetrance is: ~D~%" penetrance)
      ; (format t "The branching factor is: ~D~%" branching-factor)
      ; (format stream "The branching factor is: ~D~%" branching-factor)
      (labels 
        (
          (navigate-nodes (node)
            (cond
              ((null node) nil)
              (t (progn
                (navigate-nodes (node-previous node)) ; Go to the parent node.
                (show-node node algorithm) ; Shows information about this node.
                (if (null (node-previous node))
                  (progn 
                    (format t "Initial State: ~A~%" (node-state node))
                    (format stream "Initial State: ~A~%" (node-state node))
                  )
                  (format t "")
                )
                (format stream "NODE:~%")
                (format stream "- State: ~A~%" (node-state node))
                (format stream "- Depth: ~D~%" (node-depth node))
                (if (eq algorithm 'a-star)
                  (progn
                    (format stream "- Heuristic: ~A~%" (node-heuristic node))
                    (format stream "- Cost: ~A~%" (node-cost node))
                  )
                )
              ))
            ))
        )
        (navigate-nodes solution)
      )
    )
  )
)

(defun set-generated-nodes (value)
  (setq *generated-nodes* value)
)

(defun get-generated-nodes ()
  *generated-nodes*
)

(defun set-expanded-nodes (value)
  (setq *expanded-nodes* value)
)

(defun get-expanded-nodes ()
  *expanded-nodes*
)

