;;;; projeto.lisp
;;;; Related to user interaction and interface.
;;;; Author: Rodrigo Baptista 202200217

(defparameter *generated-nodes* 0 "Total number of generated nodes.")
(defparameter *expanded-nodes* 0 "Total number of expanded nodes.")
(defparameter *total-pieces* 0 "Total number of pieces in puzzle.")

(defparameter *output-file* (merge-pathnames "log.dat" (make-pathname :directory (pathname-directory *load-pathname*))))
(defparameter *input-file* (merge-pathnames "problemas.dat" (make-pathname :directory (pathname-directory *load-pathname*))))

(load (merge-pathnames "puzzle.lisp" (make-pathname :directory (pathname-directory *load-pathname*))))
(load (merge-pathnames "procura.lisp" (make-pathname :directory (pathname-directory *load-pathname*))))

(defun initialize ()
  (progn 
    (setq *generated-nodes* 0)
    (setq *expanded-nodes* 0)
    (setq *total-pieces* 0)
    (let 
      ((initial-node (create-node (select-problem) 0 0 nil)))
      (progn
        (setq *total-pieces* (board-piece-count (node-state initial-node)))
        (let* 
          (
            (algorithm (read-algorithm))
            (depth 
              (cond
                ((eq algorithm 'dfs) (read-depth))
              ))
            (heuristic
              (cond
                ((or (eq algorithm 'a-star) (eq algorithm 'sma-star)) (read-heuristic))
              ))
            (memory-limit 
              (cond 
                ((eq algorithm 'sma-star) (read-memory-limit))
              )
            )
            (start-time (get-internal-real-time)))
          (cond 
            ((node-solutionp initial-node) (format t "Error, the initial node can't be a solution node.~%")) ; Edge-case, the initial node is a solution node, end execution.
            ((eq algorithm 'bfs) (show-result (funcall algorithm initial-node 'node-solutionp 'generate-children 'game-operator) 'bfs start-time))
            ((eq algorithm 'dfs) (show-result (funcall algorithm initial-node 'node-solutionp 'generate-children 'game-operator depth) 'dfs start-time 0 depth))
            ((eq algorithm 'a-star) (show-result (funcall algorithm initial-node 'node-solutionp 'generate-children 'game-operator heuristic) 'a-star start-time heuristic))
            ((eq algorithm 'sma-star) (show-result (funcall algorithm initial-node 'node-solutionp 'generate-children 'game-operator heuristic memory-limit) 'sma-star start-time heuristic 0 memory-limit))
          )
        )
      )
    )
  )
)

(defun read-problems ()
  "Reads the problems from problems.dat and returns them as a list."
  (with-open-file (stream *input-file*)
    (when stream
      (loop 
        for problem = (read stream nil nil)
          while problem
            collect problem
      )
    )
  )
)

(defun select-problem ()
  "Reads the problems from problems.dat and prompts the user to select one."
  (let ((problems (read-problems)))
    (format t "Available problems:~%")
    (loop 
      for problem in problems
        for index from 1
          do (format t "~a: ~a~%" index problem)
    )
    (format t "Problem number: ")
    (let 
      (
        (choice (parse-integer (read-line) :junk-allowed t))
      )
      (if (and choice (> choice 0) (<= choice (length problems)))
        (nth (1- choice) problems)
        (progn
          (format t "Invalid choice. Please try again.~%")
          (select-problem))
      )
    )
  )
)

(defun read-depth ()
  (progn 
    (format t "What's the max depth of the search tree generated by the DFS algorithm? ~%")
    (let 
      ((depth (read)))
      (if (and (numberp depth) (> depth 0))
        depth
        (progn
          (format t "Invalid choice. Please try again.~%")
          (read-depth))
      ) 
    )
  )
)

(defun read-memory-limit ()
  (progn 
    (format t "What's the memory limit of SMA* (number of nodes to keep), number in range [100, 500]? ~%")
    (let 
      ((memory-limit (read)))
      (if (and (numberp memory-limit) (>= memory-limit 100) (<= memory-limit 500))
        memory-limit
        (progn
          (format t "Invalid choice. Please try again.~%")
          (read-memory-limit))
      ) 
    )
  )
)

(defun read-heuristic ()
  (progn 
    (format t "What heuristic function use? ~%")
    (format t "1 - Base Heuristic ~%")
    (format t "2 - Advanced Heuristic ~%")
    (format t "Heuristic: ")
    (let 
      ((heuristic (read)))
      (cond 
        ((= heuristic 1) 'game-heuristic-base)
        ((= heuristic 2) 'game-heuristic-advanced)
        (t (read-heuristic))
      )
    )
  )
)

(defun read-algorithm ()
  (progn
    (format t "What algorithm to use? ~%")
    (format t "1 - BFS ~%")
    (format t "2 - DFS ~%")
    (format t "3 - A* ~%")
    (format t "4 - SMA* ~%")
    (format t "Algorithm: ")
    (let 
      ((algorithm (read)))
      (cond 
        ((= algorithm 1) 'bfs)
        ((= algorithm 2) 'dfs)
        ((= algorithm 3) 'a-star)
        ((= algorithm 4) 'sma-star)
        (t (read-algorithm))
      )
    )
  )
)

(defun show-node (node &optional algorithm)
  (progn 
    (format t "NODE: ~%")
    (format t "- State: ~A~%" (node-state node))
    (format t "- Depth: ~D~%" (node-depth node))
    (if (eq algorithm 'a-star)
      (progn
        (format t "- Heuristic: ~A~%" (node-heuristic node))
        (format t "- Cost: ~A~%" (node-cost node))
      ) 
      nil
    )
  )
)

(defun show-result (solution algorithm start-time &optional (heuristic 0) (max-depth 0) (memory-limit 0))
  (let* 
    (
      (end-time (get-internal-real-time))
      (depth (node-depth solution))
      (time-taken (/ (- end-time start-time) (/ internal-time-units-per-second 1000)))
      (penetrance (/ (node-depth solution) *generated-nodes*))
      ; (branching-factor (calculate-branching-factor (node-depth solution) *generated-nodes*))
    )
    (with-open-file (stream *output-file* :direction :output :if-exists :append :if-does-not-exist :create)
      (cond 
        ((eq algorithm 'bfs) (format stream "Results from BFS (Breadth-First-Search): ~%"))
        ((eq algorithm 'dfs) (format stream "Results from DFS (Depth-First-Search): ~%"))
        ((eq algorithm 'a-star) 
          (progn 
            (format stream "Results from A*: ~%")
            (format stream "Heuristic used: ~A~%" heuristic)
          )
        )
        ((eq algorithm 'sma-star) 
          (progn 
            (format stream "Results from SMA*: ~%")
            (format stream "Heuristic used: ~A~%" heuristic)
            (format stream "Memory Limit: ~d~%" memory-limit)
          )
        )
      )
      (format t "Time taken: ~Dms~%" time-taken)
      (format stream "Time taken: ~Dms~%" time-taken)
      (format t "The number of total generated nodes is: ~D~%" *generated-nodes*)
      (format t "The number of total expanded nodes is: ~D~%" *expanded-nodes*)
      (format stream "The number of total generated nodes is: ~D~%" *generated-nodes*)
      (format stream "The number of total expanded nodes is: ~D~%" *expanded-nodes*)
      (format t "The penetrance is: ~,5f~%" penetrance)
      (format stream "The penetrance is: ~,5f~%" penetrance)
      (format t "Solution depth is: ~D~%" depth)
      (format stream "Solution depth is: ~D~%" depth)
      (if (eq algorithm 'dfs) (format stream "Maximum search depth is: ~A~%" max-depth))
      (labels 
        (
          (navigate-nodes (node)
            (cond
              ((null node) nil)
              (t (progn
                (navigate-nodes (node-previous node)) ; Go to the parent node.
                (if (null (node-previous node))
                  (progn 
                    (format t "Initial State: ~A~%" (node-state node))
                    (format stream "Initial State: ~A~%" (node-state node))
                  )
                  (format t "")
                )
                (show-node node algorithm) ; Shows information about this node.
                (format stream "NODE:~%")
                (format stream "- State: ~A~%" (node-state node))
                (format stream "- Depth: ~D~%" (node-depth node))
                (if (or (eq algorithm 'a-star) (eq algorithm 'sma-star))
                  (progn
                    (format stream "- Heuristic: ~A~%" (node-heuristic node))
                    (format stream "- Cost: ~A~%" (node-cost node))
                  )
                )
              ))
            ))
        )
        (navigate-nodes solution)
      )
    )
  )
)

(defun set-generated-nodes (value)
  (setq *generated-nodes* value)
)

(defun get-generated-nodes ()
  *generated-nodes*
)

(defun set-expanded-nodes (value)
  (setq *expanded-nodes* value)
)

(defun get-expanded-nodes ()
  *expanded-nodes*
)

(defun get-total-pieces ()
  *total-pieces*
)

